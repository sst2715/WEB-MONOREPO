import * as AST from '@eslint-react/ast';
import { O } from '@eslint-react/tools';
import { TSESTree } from '@typescript-eslint/types';
import { RuleContext } from '@eslint-react/types';
import { TSESTree as TSESTree$1 } from '@typescript-eslint/utils';
import * as _typescript_eslint_utils_ts_eslint from '@typescript-eslint/utils/ts-eslint';
import { ESLintReactSettings } from '@eslint-react/shared';
import { Scope } from '@typescript-eslint/scope-manager';
import * as birecord from 'birecord';

/**
 * Checks if the given node is a call expression to the given function or method of the pragma
 * @param name The name of the function or method to check
 * @returns A predicate that checks if the given node is a call expression to the given function or method
 */
declare function isFromReact(name: string): (node: TSESTree.Identifier | TSESTree.MemberExpression, context: RuleContext) => boolean;
/**
 * @internal
 * @param memberName The name of the member object
 * @param name The name of the member property
 * @returns A function that checks if a given node is a member expression of a Pragma member.
 */
declare function isFromReactMember(memberName: string, name: string): (node: TSESTree.MemberExpression, context: RuleContext) => boolean;
declare function isCallFromReact(name: string): (node: TSESTree.CallExpression, context: RuleContext) => boolean;
declare function isCallFromReactMember(pragmaMemberName: string, name: string): (node: TSESTree.CallExpression, context: RuleContext) => boolean;

/**
 * Check if an identifier is initialized from React
 * @param name The top-level identifier's name
 * @param initialScope Initial scope to search for the identifier
 * @param settings ESLint React settings
 * @returns Whether the identifier is initialized from React
 */
declare function isInitializedFromReact(name: string, initialScope: Scope, settings: Partial<Pick<ESLintReactSettings, "importSource" | "skipImportCheck">>): boolean;

declare function isReactAPIWithName(name: string): ReturnType<typeof isFromReact>;
declare function isReactAPIWithName(name: string, member: string): ReturnType<typeof isFromReactMember>;
declare function isReactAPICallWithName(name: string): ReturnType<typeof isCallFromReact>;
declare function isReactAPICallWithName(name: string, member: string): ReturnType<typeof isCallFromReactMember>;

type EREffectPhaseKind = "cleanup" | "setup";
type ERLifecyclePhaseKind = "mount" | "unmount";
type ERPhaseKind = EREffectPhaseKind | ERLifecyclePhaseKind;

interface ERSemanticEntry {
    node: TSESTree.Node;
    phase: ERPhaseKind;
}

interface ERSemanticNode {
    _: string;
    id: O.Option<TSESTree.Identifier | TSESTree.Identifier[]>;
    kind: string;
    name: O.Option<string>;
    node: TSESTree.Node;
    flag: bigint;
    hint: bigint;
}

type ERComponentHint = bigint;
/**
 * hints for component collector
 */
declare const ERComponentHint: {
    readonly SkipMemo: bigint;
    readonly SkipForwardRef: bigint;
    readonly SkipMapCallback: bigint;
    readonly SkipObjectMethod: bigint;
    readonly SkipClassMethod: bigint;
    readonly SkipClassProperty: bigint;
    readonly None: 0n;
    readonly SkipNullLiteral: bigint;
    readonly SkipUndefinedLiteral: bigint;
    readonly SkipBooleanLiteral: bigint;
    readonly SkipStringLiteral: bigint;
    readonly SkipNumberLiteral: bigint;
    readonly SkipCreateElement: bigint;
    readonly SkipEmptyArray: bigint;
    readonly StrictArray: bigint;
    readonly StrictLogical: bigint;
    readonly StrictConditional: bigint;
};
declare const DEFAULT_COMPONENT_HINT: bigint;

type ERClassComponentFlag = bigint;
declare const ERClassComponentFlag: {
    None: bigint;
    PureComponent: bigint;
};
type ERFunctionComponentFlag = bigint;
declare const ERFunctionComponentFlag: {
    None: bigint;
    Memo: bigint;
    ForwardRef: bigint;
};

interface ERFunctionComponent extends ERSemanticNode {
    id: O.Option<TSESTree.Identifier | TSESTree.Identifier[]>;
    kind: "function";
    node: AST.TSESTreeFunction;
    flag: ERFunctionComponentFlag;
    hint: ERComponentHint;
    initPath: O.Option<AST.FunctionInitPath>;
    hookCalls: TSESTree.CallExpression[];
    displayName: O.Option<TSESTree.Expression>;
}
interface ERClassComponent extends ERSemanticNode {
    id: O.Option<TSESTree.Identifier>;
    kind: "class";
    node: AST.TSESTreeClass;
    flag: ERClassComponentFlag;
    hint: ERComponentHint;
    methods: (TSESTree.MethodDefinition | TSESTree.PropertyDefinition)[];
    displayName: O.Option<TSESTree.Expression>;
}
type ERComponent = ERClassComponent | ERFunctionComponent;

declare function useComponentCollector(context: RuleContext, hint?: bigint): {
    readonly ctx: {
        readonly getAllComponents: (_: TSESTree.Program) => Map<string, ERFunctionComponent>;
        readonly getCurrentComponents: () => Map<string, ERFunctionComponent>;
        readonly getCurrentFunction: () => O.Option<[key: string, node: AST.TSESTreeFunction, isComponent: boolean, hookCalls: TSESTree.CallExpression[]]>;
        readonly getCurrentFunctionStack: () => [key: string, node: AST.TSESTreeFunction, isComponent: boolean, hookCalls: TSESTree.CallExpression[]][];
    };
    readonly listeners: {
        readonly ":function[type]": (node: AST.TSESTreeFunction) => number;
        readonly ":function[type]:exit": () => [key: string, node: AST.TSESTreeFunction, isComponent: boolean, hookCalls: TSESTree.CallExpression[]] | undefined;
        readonly "ArrowFunctionExpression[type][body.type!='BlockStatement']": () => void;
        readonly "AssignmentExpression[type][operator='='][left.type='MemberExpression'][left.property.name='displayName']": (node: TSESTree.Node) => void;
        readonly "CallExpression[type]:exit": (node: TSESTree.CallExpression) => void;
        readonly "ReturnStatement[type]": (node: TSESTree.ReturnStatement) => void;
    };
};

/**
 * Check if a node is a React class component
 * @param node The AST node to check
 * @returns `true` if the node is a class component, `false` otherwise
 */
declare function isClassComponent(node: TSESTree$1.Node): node is AST.TSESTreeClass;
/**
 * Check if a node is a React PureComponent
 * @param node The AST node to check
 * @returns `true` if the node is a pure component, `false` otherwise
 */
declare function isPureComponent(node: TSESTree$1.Node): boolean;
declare function isComponentDidMount(node: TSESTree$1.Node): node is TSESTree$1.MethodDefinition | TSESTree$1.PropertyDefinition;
declare function isComponentWillUnmount(node: TSESTree$1.Node): node is TSESTree$1.MethodDefinition | TSESTree$1.PropertyDefinition;
declare function isComponentDidMountFunction(node: TSESTree$1.Node): boolean;
declare function isComponentWillUnmountFunction(node: TSESTree$1.Node): boolean;
declare function useComponentCollectorLegacy(): {
    readonly ctx: {
        readonly getAllComponents: (_: TSESTree$1.Program) => Map<string, ERClassComponent>;
        readonly getCurrentComponents: () => Map<string, ERClassComponent>;
    };
    readonly listeners: {
        readonly "ClassDeclaration[type]": (node: AST.TSESTreeClass) => void;
        readonly "ClassExpression[type]": (node: AST.TSESTreeClass) => void;
    };
};

declare function getFunctionComponentIdentifier(node: AST.TSESTreeFunction, context: RuleContext): O.Option<TSESTree.Identifier | TSESTree.Identifier[]>;

type ERComponentKind = "classComponent" | "functionComponent";

type EREffectMethodKind = "useEffect" | "useInsertionEffect" | "useLayoutEffect";
type ERLifecycleMethodKind = "componentDidMount" | "componentWillUnmount";

declare const RE_COMPONENT_NAME: RegExp;
declare function getComponentNameFromIdentifier(node: TSESTree.Identifier | TSESTree.Identifier[]): string;
declare function isComponentName(name: string): boolean;

declare function isFunctionOfRenderMethod(node: AST.TSESTreeFunction): boolean;
/**
 * Check whether given node is declared inside class component's render block
 * ```jsx
 * class Component extends React.Component {
 *   render() {
 *     class NestedClassComponent extends React.Component {
 *      render() { return <div />; }
 *     }
 *     const nestedFunctionComponent = () => <div />;
 *  }
 * }
 * ```
 * @param node The AST node being checked
 * @returns `true` if node is inside class component's render block, `false` if not
 */
declare function isInsideRenderMethod(node: TSESTree$1.Node): boolean;

declare function hasNoneOrValidComponentName(node: AST.TSESTreeFunction, context: RuleContext): boolean;

type EREffectKind = "effect" | "insertionEffect" | "layoutEffect";

declare function isSetupFunction(node: TSESTree.Node): boolean;
declare function isCleanupFunction(node: TSESTree.Node): boolean;

/**
 * Determines whether inside createElement's props.
 * @param node The AST node to check
 * @param context The rule context
 * @returns `true` if the node is inside createElement's props
 */
declare function isInsideCreateElementProps(node: TSESTree.Node, context: RuleContext): boolean;
declare function isChildrenOfCreateElement(node: TSESTree.Node, context: RuleContext): boolean;

/**
 * Check if a node is `<Fragment></Fragment>` or `<Pragma.Fragment></Pragma.Fragment>`
 * @param node The JSX element node to check
 * @param context The rule context
 * @returns `true` if the node is a fragment element, `false` otherwise
 */
declare function isFragmentElement(node: TSESTree.JSXElement, context: RuleContext): boolean;

declare function isInsideReactHook(node: TSESTree.Node): boolean;
declare function isInsideReactHookCall(node: TSESTree.Node): boolean;

interface ERHook extends ERSemanticNode {
    id: O.Some<TSESTree.Identifier>;
    node: AST.TSESTreeFunction;
    name: O.Some<string>;
    hookCalls: TSESTree.CallExpression[];
}

declare function useHookCollector(): {
    readonly ctx: {
        readonly getAllHooks: (_: TSESTree$1.Program) => Map<string, ERHook>;
        readonly getCurrentHooks: () => Map<string, ERHook>;
    };
    readonly listeners: {
        readonly ":function[type]": (node: AST.TSESTreeFunction) => void;
        readonly ":function[type]:exit": () => void;
        readonly "CallExpression[type]": (node: never) => void;
    };
};

type ERHookKind = "custom" | "useActionState" | "useCallback" | "useContext" | "useDebugValue" | "useDeferredValue" | "useEffect" | "useId" | "useImperativeHandle" | "useInsertionEffect" | "useLayoutEffect" | "useMemo" | "useOptimistic" | "useReducer" | "useRef" | "useState" | "useSyncExternalStore" | "useTransition";

declare const RE_HOOK_NAME: RegExp;
declare function isReactHookName(name: string): boolean;

declare function isReactHook(node: AST.TSESTreeFunction): boolean;
/**
 * Check if the given node is a React Hook call by its name.
 * @param node The node to check.
 * @returns `true` if the node is a React Hook call, `false` otherwise.
 */
declare function isReactHookCall(node: TSESTree.CallExpression): boolean;
declare function isReactHookCallWithName(node: TSESTree.CallExpression, context: RuleContext): (name: string) => boolean;
declare function isReactHookCallWithNameLoose(node: TSESTree.CallExpression): (name: string) => boolean;
declare function isReactHookCallWithNameAlias(name: string, context: RuleContext, alias: string[]): (node: TSESTree.CallExpression) => boolean;
declare function isUseEffectCallLoose(node: TSESTree.Node): boolean;
declare const isUseCallbackCall: (node: TSESTree.CallExpression, context: Readonly<_typescript_eslint_utils_ts_eslint.RuleContext<string, readonly unknown[]>>) => boolean;
declare const isUseContextCall: (node: TSESTree.CallExpression, context: Readonly<_typescript_eslint_utils_ts_eslint.RuleContext<string, readonly unknown[]>>) => boolean;
declare const isUseDebugValueCall: (node: TSESTree.CallExpression, context: Readonly<_typescript_eslint_utils_ts_eslint.RuleContext<string, readonly unknown[]>>) => boolean;
declare const isUseDeferredValueCall: (node: TSESTree.CallExpression, context: Readonly<_typescript_eslint_utils_ts_eslint.RuleContext<string, readonly unknown[]>>) => boolean;
declare const isUseEffectCall: (node: TSESTree.CallExpression, context: Readonly<_typescript_eslint_utils_ts_eslint.RuleContext<string, readonly unknown[]>>) => boolean;
declare const isUseIdCall: (node: TSESTree.CallExpression, context: Readonly<_typescript_eslint_utils_ts_eslint.RuleContext<string, readonly unknown[]>>) => boolean;
declare const isUseImperativeHandleCall: (node: TSESTree.CallExpression, context: Readonly<_typescript_eslint_utils_ts_eslint.RuleContext<string, readonly unknown[]>>) => boolean;
declare const isUseInsertionEffectCall: (node: TSESTree.CallExpression, context: Readonly<_typescript_eslint_utils_ts_eslint.RuleContext<string, readonly unknown[]>>) => boolean;
declare const isUseLayoutEffectCall: (node: TSESTree.CallExpression, context: Readonly<_typescript_eslint_utils_ts_eslint.RuleContext<string, readonly unknown[]>>) => boolean;
declare const isUseMemoCall: (node: TSESTree.CallExpression, context: Readonly<_typescript_eslint_utils_ts_eslint.RuleContext<string, readonly unknown[]>>) => boolean;
declare const isUseReducerCall: (node: TSESTree.CallExpression, context: Readonly<_typescript_eslint_utils_ts_eslint.RuleContext<string, readonly unknown[]>>) => boolean;
declare const isUseRefCall: (node: TSESTree.CallExpression, context: Readonly<_typescript_eslint_utils_ts_eslint.RuleContext<string, readonly unknown[]>>) => boolean;
declare const isUseStateCall: (node: TSESTree.CallExpression, context: Readonly<_typescript_eslint_utils_ts_eslint.RuleContext<string, readonly unknown[]>>) => boolean;
declare const isUseSyncExternalStoreCall: (node: TSESTree.CallExpression, context: Readonly<_typescript_eslint_utils_ts_eslint.RuleContext<string, readonly unknown[]>>) => boolean;
declare const isUseTransitionCall: (node: TSESTree.CallExpression, context: Readonly<_typescript_eslint_utils_ts_eslint.RuleContext<string, readonly unknown[]>>) => boolean;

declare const PHASE_RELEVANCE: birecord.BiRecord<{
    readonly mount: "unmount";
    readonly setup: "cleanup";
}>;
declare const isInversePhase: {
    (a: ERPhaseKind): (b: ERPhaseKind) => boolean;
    (a: ERPhaseKind, b: ERPhaseKind): boolean;
};
declare function getPhaseKindOfFunction(node: AST.TSESTreeFunction): O.Option<ERPhaseKind>;

type A = (node: TSESTree.Identifier | TSESTree.MemberExpression, context: RuleContext) => boolean;
type B = (node: TSESTree.MemberExpression, context: RuleContext, pragma?: string) => boolean;
type X = (node: TSESTree.CallExpression, context: RuleContext) => boolean;
type Y = (node: TSESTree.CallExpression, context: RuleContext, pragma?: string) => boolean;
declare const isChildrenCount: B;
declare const isChildrenForEach: B;
declare const isChildrenMap: B;
declare const isChildrenOnly: B;
declare const isChildrenToArray: B;
declare const isCloneElement: A;
declare const isCreateContext: A;
declare const isCreateElement: A;
declare const isCreateRef: A;
declare const isForwardRef: A;
declare const isMemo: A;
declare const isChildrenCountCall: Y;
declare const isChildrenForEachCall: Y;
declare const isChildrenMapCall: Y;
declare const isChildrenOnlyCall: Y;
declare const isChildrenToArrayCall: Y;
declare const isCloneElementCall: X;
declare const isCreateContextCall: X;
declare const isCreateElementCall: X;
declare const isCreateRefCall: X;
declare const isForwardRefCall: X;
declare const isMemoCall: X;

/**
 * Unsafe check whether given node is declared directly inside a render property
 * ```jsx
 * const rows = { render: () => <div /> }
 * `                      ^^^^^^^^^^^^^ `
 * _ = <Component rows={ [{ render: () => <div /> }] } />
 * `                                ^^^^^^^^^^^^^       `
 *  ```
 * @internal
 * @param node The AST node to check
 * @returns `true` if component is declared inside a render property, `false` if not
 */
declare function isDirectValueOfRenderPropertyLoose(node: TSESTree.Node): boolean;
/**
 * Unsafe check whether given node is declared inside a render prop
 * ```jsx
 * _ = <Component renderRow={"node"} />
 * `                         ^^^^^^   `
 * _ = <Component rows={ [{ render: "node" }] } />
 * `                                ^^^^^^       `
 * ```
 * @param node The AST node to check
 * @returns `true` if component is declared inside a render prop, `false` if not
 */
declare function isDeclaredInRenderPropLoose(node: TSESTree.Node): boolean;

/**
 * Unsafe check whether given node is a render function
 * ```jsx
 * const renderRow = () => <div />
 * `                 ^^^^^^^^^^^^`
 * _ = <Component renderRow={() => <div />} />
 * `                         ^^^^^^^^^^^^^   `
 * ```
 * @param node The AST node to check
 * @param context The rule context
 * @returns `true` if node is a render function, `false` if not
 */
declare function isRenderFunctionLoose(node: AST.TSESTreeFunction, context: RuleContext): boolean;
/**
 * Unsafe check whether given JSXAttribute is a render prop
 * ```jsx
 * _ = <Component renderRow={() => <div />} />
 * `              ^^^^^^^^^^^^^^^^^^^^^^^^^  `
 * ```
 * @param node The AST node to check
 * @param context The rule context
 * @returns `true` if node is a render prop, `false` if not
 */
declare function isRenderPropLoose(node: TSESTree.JSXAttribute, context: RuleContext): boolean;

declare function isThisSetState(node: TSESTree.CallExpression): boolean;

type ERStateKind = "actionState" | "state";

export { DEFAULT_COMPONENT_HINT, type ERClassComponent, ERClassComponentFlag, type ERComponent, ERComponentHint, type ERComponentKind, type EREffectKind, type EREffectMethodKind, type EREffectPhaseKind, type ERFunctionComponent, ERFunctionComponentFlag, type ERHook, type ERHookKind, type ERLifecycleMethodKind, type ERLifecyclePhaseKind, type ERPhaseKind, type ERSemanticEntry, type ERSemanticNode, type ERStateKind, PHASE_RELEVANCE, RE_COMPONENT_NAME, RE_HOOK_NAME, getComponentNameFromIdentifier, getFunctionComponentIdentifier, getPhaseKindOfFunction, hasNoneOrValidComponentName, isCallFromReact, isCallFromReactMember, isChildrenCount, isChildrenCountCall, isChildrenForEach, isChildrenForEachCall, isChildrenMap, isChildrenMapCall, isChildrenOfCreateElement, isChildrenOnly, isChildrenOnlyCall, isChildrenToArray, isChildrenToArrayCall, isClassComponent, isCleanupFunction, isCloneElement, isCloneElementCall, isComponentDidMount, isComponentDidMountFunction, isComponentName, isComponentWillUnmount, isComponentWillUnmountFunction, isCreateContext, isCreateContextCall, isCreateElement, isCreateElementCall, isCreateRef, isCreateRefCall, isDeclaredInRenderPropLoose, isDirectValueOfRenderPropertyLoose, isForwardRef, isForwardRefCall, isFragmentElement, isFromReact, isFromReactMember, isFunctionOfRenderMethod, isInitializedFromReact, isInsideCreateElementProps, isInsideReactHook, isInsideReactHookCall, isInsideRenderMethod, isInversePhase, isMemo, isMemoCall, isPureComponent, isReactAPICallWithName, isReactAPIWithName, isReactHook, isReactHookCall, isReactHookCallWithName, isReactHookCallWithNameAlias, isReactHookCallWithNameLoose, isReactHookName, isRenderFunctionLoose, isRenderPropLoose, isSetupFunction, isThisSetState, isUseCallbackCall, isUseContextCall, isUseDebugValueCall, isUseDeferredValueCall, isUseEffectCall, isUseEffectCallLoose, isUseIdCall, isUseImperativeHandleCall, isUseInsertionEffectCall, isUseLayoutEffectCall, isUseMemoCall, isUseReducerCall, isUseRefCall, isUseStateCall, isUseSyncExternalStoreCall, isUseTransitionCall, useComponentCollector, useComponentCollectorLegacy, useHookCollector };
